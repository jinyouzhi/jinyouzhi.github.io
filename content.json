[{"title":"计蒜客 计蒜之道2017初赛第四场","date":"2017-05-31T13:52:06.000Z","path":"2017/05/31/jisuanke-2017-preliminary-4/","text":"题目链接比赛：https://www.jisuanke.com/contest/729 A. 商汤科技的安全令牌 题库链接 B. 商汤科技的行人检测（简单） 题库链接 C. 商汤科技的行人检测（中等） 题库链接 D. 商汤科技的行人检测（困难） 题库链接 题目解答官方题解：https://www.jisuanke.com/article/5a796674 A题（现场AC）这题很简单，就是统计分割后的各块分别能放下多少对，简单推理一下，都是矩形区域，物体是占相邻两个孔，所以只要统计一下面积整除$2$就行。 具体做法：用两个vector统计行和列上的界（被焊上的），事先加入$0$和$n+1$($m+1$)，然后排序，两层循环扫描行列。 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; r, c;int n, m, k;int main()&#123; int x, y, res = 0, h, w; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; r.push_back(0);r.push_back(n + 1); c.push_back(0);c.push_back(m + 1); for (int i = 0; i &lt; k; ++i) &#123; cin&gt;&gt;x&gt;&gt;y; if (x == 0) r.push_back(y); else c.push_back(y); &#125; sort(r.begin(), r.end()); sort(c.begin(), c.end()); for (int i = 1; i &lt; r.size(); ++i) for (int j = 1; j &lt; c.size(); ++j) &#123; h = r[i] - r[i - 1] - 1; w = c[j] - c[j - 1] - 1; res += (h * w) / 2; //cout&lt;&lt;i&lt;&lt;' '&lt;&lt;j&lt;&lt;endl; //cout&lt;&lt;r[i]&lt;&lt; ' '&lt;&lt;c[j]&lt;&lt;endl; &#125; cout&lt;&lt;res&lt;&lt;endl; return 0;&#125; B题（现场AC）也是水题，统计位移dx和dy出现次数最多的那组是否超过$n/2$即可，否则输出任意值。 1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;#include &lt;map&gt;#include &lt;algorithm&gt;#include &lt;utility&gt;using namespace std;map&lt;pair&lt;int, int&gt;, int&gt; m;map&lt;pair&lt;int, int&gt;, int&gt;::iterator it, res;int main()&#123; int x1, x2, y1,y2, dx, dy,n; scanf(\"%d\", &amp;n); for (int i = 0;i &lt; n; ++i) &#123; scanf(\"%d%d%d%d\", &amp;x1,&amp;y1,&amp;x2,&amp;y2); dx = x2-x1;dy=y2-y1; it = m.find(make_pair(dx, dy)); if (it != m.end()) ++it-&gt;second; else m.insert(make_pair(make_pair(dx, dy), 1)); &#125; res = m.end(); for (it = m.begin();it!=m.end(); ++it) if(it-&gt;second * 2&gt;= n) &#123; res = it; &#125; if (res == m.end()) printf(\"%d %d\\n\", 0, 0); else printf(\"%d %d\\n\", res-&gt;first.first, res-&gt;first.second); return 0;&#125; C题（赛后补题）看官方题解补的题，跟D一样。 D题（赛后补题）枚举任意两对，分别计算出$\\theta$、$scale$、$d_x$、$d_y$，代入$n$对点统计是否超过一半。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;using namespace std;const int MAXN = 1e5 + 6;const double eps = 1e-4;inline double dis(double x1, double y1, double x2 = 0.0, double y2 = 0.0)&#123; return sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));&#125;inline int sgn(double x, double y)&#123; if (fabs(x - y) &lt; eps) return 0; return x &lt; y ? - 1 : 1;&#125;int n;double x[MAXN][2], y[MAXN][2];double ans[4];int main()&#123; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; ++i) &#123; scanf(\"%lf%lf%lf%lf\", &amp;x[i][0], &amp;y[i][0], &amp;x[i][1], &amp;y[i][1]); &#125; if (n == 1) &#123; ans[0] = 0.0; ans[1] = 1.0; ans[2] = x[0][1] - x[0][0]; ans[3] = y[0][1] - y[0][0]; &#125; else for (int k = 0; k &lt; 1000; ++k) &#123; int i, j; double disc, disr, dx[3], dy[3]; double dotx, mod, rtdeg, scale; i = rand() % n; j = rand() % n; while(i == j) j = rand() % n; //放大 disc = dis(x[i][1], y[i][1], x[j][1], y[j][1]); disr = dis(x[i][0], y[i][0], x[j][0], y[j][0]); if (sgn(disr, 0.0) == 0) continue; scale = disc / disr; dx[0] = x[i][0] - x[j][0]; dy[0] = y[i][0] - y[j][0]; dx[1] = x[i][1] - x[j][1]; dy[1] = y[i][1] - y[j][1]; //向量求夹角 dotx = dx[0] * dx[1] + dy[0] * dy[1]; mod = dis(dx[0], dy[0]) * dis(dx[1], dy[1]); rtdeg = acos(dotx / mod); //位移 dx[2] = x[i][1] - (x[i][0] * cos(rtdeg) - y[i][0] * sin(rtdeg)) * scale; dy[2] = y[i][1] - (x[i][0] * sin(rtdeg) + y[i][0] * cos(rtdeg)) * scale; //检验 int cnt = 0; for (int l = 0; l &lt; n; ++l) &#123; double xx = (x[l][0] * cos(rtdeg) - y[l][0] * sin(rtdeg)) * scale + dx[2]; double yy = (x[l][0] * sin(rtdeg) + y[l][0] * cos(rtdeg)) * scale + dy[2]; if (sgn(dis(xx, yy, x[l][1], y[l][1]), 0.0) == 0) ++cnt; &#125; if (cnt * 2 &gt;= n) &#123; ans[0] = rtdeg; ans[1] = scale; ans[2] = dx[2]; ans[3] = dy[2]; break; &#125; &#125; printf(\"%.10lf\\n%.10lf\\n%.10lf %.10lf\\n\", ans[0], ans[1], ans[2], ans[3]); return 0;&#125; 吐槽本来约好开黑打的，结果他们都没按时出现，我等舍友吃饭等了一个小时，回宿舍已经17:20了，于是慢慢切水题，20分钟切完两题懵逼了，三四题不会做，直接进入辣鸡时间，全场都两题滚粗，于是放弃治疗，赛后发现也就10人A了C。本来坐等下次再打，后来发现竟然晋级了，最近RP太好，好得害怕。","tags":[{"name":"算法","slug":"算法","permalink":"http://jinyouzhi.github.io/tags/算法/"},{"name":"水题","slug":"水题","permalink":"http://jinyouzhi.github.io/tags/水题/"}]},{"title":"使用ImageQt将Image转换成 QImage","date":"2017-04-12T11:42:35.000Z","path":"2017/04/12/PIL-Image-to-QImage/","text":"昨天做数字图像处理实验平滑处理部分，我选择的是Python编写，GUI使用PyQt5，使用了图像库PIL读取文件，然后转为numpy数组进行处理，再由PyQt5的QImage控件显示。这其中出现一个问题，numpy数组的图像数据再转为图像显示的实现方式，没有特别成熟的方案。在前几次实验中使用QPixmap、QPainter绘制的方式，还有metaplot的plot绘制的方式再输出为文件到缓冲区，再用QImage读取文件的方式从缓冲区取出显示。昨天研究Image的时候发现Image有一个ImageQt和ImageTK类是用于向这两种GUI的图形控件输出的方法。但Google遍中文英文包括官方文档都没有关于的这个方法的具体使用范例，最终在一家日文网站发现了办法，思路上大体还是输出到缓冲区再读回的办法，但已经比之前的方法高雅多了。改进日文网站后我的写法：123456def image2qimage(self, image): img_buffer = io.BytesIO() image.save(img_buffer, \"BMP\") qimage = QImage() qimage.loadFromData(img_buffer.getvalue(), \"BMP\") return qimage 顺便知道了Qiita是日本一家程序员技术分享网站 参考PIL/Pillow チートシート - QiitaPIL.Image と PyQt4.QtGui.QImageの相互変換Pillow ImageQt Module","tags":[{"name":"PyQt","slug":"PyQt","permalink":"http://jinyouzhi.github.io/tags/PyQt/"},{"name":"Image","slug":"Image","permalink":"http://jinyouzhi.github.io/tags/Image/"},{"name":"数字图像处理","slug":"数字图像处理","permalink":"http://jinyouzhi.github.io/tags/数字图像处理/"},{"name":"ImageQt","slug":"ImageQt","permalink":"http://jinyouzhi.github.io/tags/ImageQt/"}]},{"title":"Tensor Decomposition（张量分解）工具箱","date":"2017-04-11T09:00:54.000Z","path":"2017/04/11/Tensor-Decomposition-Toolbox/","text":"Python scikit-tensorGitHub - mnick/scikit-tensor: Python library for multilinear algebra and tensor factorizations简单review了Tucker分解代码，初始量可以Random生成或者在HOSVD上做。 ttpyGitHub - oseledets/ttpy TensorToolboxTensorToolbox PyTensor是把Matlab的Tensor Toolbox 的Python版本，2009年最后更新论文：CMU代码：Google Code、搬运到GitHub MATLAB TTGitHub - oseledets/TT-Toolbox Tensor ToolboxTensor Toolbox References知乎-Python 中有计算tensor 的包吗？特别是关于tensor decomposition？","tags":[{"name":"Tensor(张量)","slug":"Tensor-张量","permalink":"http://jinyouzhi.github.io/tags/Tensor-张量/"},{"name":"Python","slug":"Python","permalink":"http://jinyouzhi.github.io/tags/Python/"},{"name":"MATLAB","slug":"MATLAB","permalink":"http://jinyouzhi.github.io/tags/MATLAB/"}]},{"title":"【Trie树】POJ 3764 最大连续异或和","date":"2017-03-27T14:35:15.000Z","path":"2017/03/27/POJ3764/","text":"题意已知：给出n个结点的树，定义两结点间的权值为两点之间所有边相异或的值。求：树中的某两点间的最大权值。 解法是道好题，在做HDU5845，发现Trie树解决连续异或和问题是很有趣的套路，遂找到这题学习。//TODO 代码POJ 数据范围有坑，TLE半天，点开Discuss发现数据范围可能是200000。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129//Trie树求最大/最小连续异或和#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int MAXN = 2e5 + 6;const int MAXBIT = 30;struct edge&#123; int nx, v, w;&#125;e[MAXN &lt;&lt; 1];int last[MAXN];int etot;int n;struct Trie&#123; int child[2]; void init() &#123; child[1] = child[0] = -1; &#125;&#125;tr[MAXN &lt;&lt; 5];int cnt;bool vis[MAXN];int XOR[MAXN];void add_edge(int u, int v, int w)&#123; e[etot].nx = last[u]; e[etot].v = v; e[etot].w = w; last[u] = etot++; e[etot].nx = last[v]; e[etot].v = u; e[etot].w = w; last[v] = etot++;&#125;void Insert(int x)&#123; int cur = 0; for (int i = MAXBIT; i &gt;= 0; --i) &#123; int k = (x &gt;&gt; i) &amp; 1; if (tr[cur].child[k] == -1) &#123; tr[cur].child[k] = ++cnt; tr[cnt].init(); &#125; cur = tr[cur].child[k]; &#125;&#125;int Find(int x)&#123; int cur = 0; int ans = 0; for (int i = MAXBIT; i &gt;= 0; --i) &#123; int k = ((x &gt;&gt; i) &amp; 1)? 0 : 1; if (tr[cur].child[k] != -1) &#123; ans |= (1 &lt;&lt; i); cur = tr[cur].child[k]; &#125; else cur = tr[cur].child[1 - k]; &#125; return ans;&#125;void dfs(int u)&#123; //Insert(XOR[u]); vis[u] = 1; for(int k = last[u]; k != -1; k = e[k].nx) &#123; if (vis[e[k].v]) continue; else XOR[e[k].v] = XOR[u] ^ e[k].w; dfs(e[k].v); &#125;&#125;void init()&#123; etot = 0; //memset(last, 0xFF, sizeof(last)); cnt = 0; tr[0].init(); for(int i = 0; i &lt; n; ++i) &#123; last[i] = -1; vis[i] = XOR[i] = 0; &#125; //memset(vis, 0, sizeof(vis)); //memset(XOR, 0, sizeof(XOR));&#125;int main()&#123; int ans, u, v, w; //while(cin&gt;&gt;n) while(scanf(\"%d\", &amp;n) == 1) &#123; init(); for (int i = 1; i &lt; n; ++i) &#123; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); //cin&gt;&gt;u&gt;&gt;v&gt;&gt;w; add_edge(u,v,w); &#125; dfs(0); ans = -1; for (int i = 0; i &lt; n; ++i) &#123; Insert(XOR[i]); int t = Find(XOR[i]); ans = max(ans, t); &#125; printf(\"%d\\n\", ans); //cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; 参考http://codecloud.net/86072.htmlhttps://problemsolvingnotes.wordpress.com/2012/02/22/poj-3764-the-xor-longest-path/","tags":[{"name":"ACM","slug":"ACM","permalink":"http://jinyouzhi.github.io/tags/ACM/"},{"name":"POJ","slug":"POJ","permalink":"http://jinyouzhi.github.io/tags/POJ/"},{"name":"Trie","slug":"Trie","permalink":"http://jinyouzhi.github.io/tags/Trie/"}]},{"title":"Hello World","date":"2017-03-26T15:59:04.231Z","path":"2017/03/26/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]