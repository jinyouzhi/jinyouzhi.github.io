[{"title":"Tensor Decomposition（张量分解）工具箱","date":"2017-04-11T09:00:54.000Z","path":"2017/04/11/Tensor-Decomposition-Toolbox/","text":"Python scikit-tensorGitHub - mnick/scikit-tensor: Python library for multilinear algebra and tensor factorizations简单review了Tucker分解代码，初始量可以Random生成或者在HOSVD上做。 ttpyGitHub - oseledets/ttpy TensorToolboxTensorToolbox PyTensor是把Matlab的Tensor Toolbox 的Python版本，2009年最后更新论文：CMU代码：Google Code、搬运到GitHub MATLAB TTGitHub - oseledets/TT-Toolbox Tensor ToolboxTensor Toolbox References知乎-Python 中有计算tensor 的包吗？特别是关于tensor decomposition？","tags":[{"name":"Tensor(张量) Python MATLAB","slug":"Tensor-张量-Python-MATLAB","permalink":"http://jinyouzhi.github.io/tags/Tensor-张量-Python-MATLAB/"}]},{"title":"【Trie树】POJ 3764 最大连续异或和","date":"2017-03-27T14:35:15.000Z","path":"2017/03/27/POJ3764/","text":"题意已知：给出n个结点的树，定义两结点间的权值为两点之间所有边相异或的值。求：树中的某两点间的最大权值。 解法是道好题，在做HDU5845，发现Trie树解决连续异或和问题是很有趣的套路，遂找到这题学习。//TODO 代码POJ 数据范围有坑，TLE半天，点开Discuss发现数据范围可能是200000。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129//Trie树求最大/最小连续异或和#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int MAXN = 2e5 + 6;const int MAXBIT = 30;struct edge&#123; int nx, v, w;&#125;e[MAXN &lt;&lt; 1];int last[MAXN];int etot;int n;struct Trie&#123; int child[2]; void init() &#123; child[1] = child[0] = -1; &#125;&#125;tr[MAXN &lt;&lt; 5];int cnt;bool vis[MAXN];int XOR[MAXN];void add_edge(int u, int v, int w)&#123; e[etot].nx = last[u]; e[etot].v = v; e[etot].w = w; last[u] = etot++; e[etot].nx = last[v]; e[etot].v = u; e[etot].w = w; last[v] = etot++;&#125;void Insert(int x)&#123; int cur = 0; for (int i = MAXBIT; i &gt;= 0; --i) &#123; int k = (x &gt;&gt; i) &amp; 1; if (tr[cur].child[k] == -1) &#123; tr[cur].child[k] = ++cnt; tr[cnt].init(); &#125; cur = tr[cur].child[k]; &#125;&#125;int Find(int x)&#123; int cur = 0; int ans = 0; for (int i = MAXBIT; i &gt;= 0; --i) &#123; int k = ((x &gt;&gt; i) &amp; 1)? 0 : 1; if (tr[cur].child[k] != -1) &#123; ans |= (1 &lt;&lt; i); cur = tr[cur].child[k]; &#125; else cur = tr[cur].child[1 - k]; &#125; return ans;&#125;void dfs(int u)&#123; //Insert(XOR[u]); vis[u] = 1; for(int k = last[u]; k != -1; k = e[k].nx) &#123; if (vis[e[k].v]) continue; else XOR[e[k].v] = XOR[u] ^ e[k].w; dfs(e[k].v); &#125;&#125;void init()&#123; etot = 0; //memset(last, 0xFF, sizeof(last)); cnt = 0; tr[0].init(); for(int i = 0; i &lt; n; ++i) &#123; last[i] = -1; vis[i] = XOR[i] = 0; &#125; //memset(vis, 0, sizeof(vis)); //memset(XOR, 0, sizeof(XOR));&#125;int main()&#123; int ans, u, v, w; //while(cin&gt;&gt;n) while(scanf(\"%d\", &amp;n) == 1) &#123; init(); for (int i = 1; i &lt; n; ++i) &#123; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); //cin&gt;&gt;u&gt;&gt;v&gt;&gt;w; add_edge(u,v,w); &#125; dfs(0); ans = -1; for (int i = 0; i &lt; n; ++i) &#123; Insert(XOR[i]); int t = Find(XOR[i]); ans = max(ans, t); &#125; printf(\"%d\\n\", ans); //cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; 参考http://codecloud.net/86072.htmlhttps://problemsolvingnotes.wordpress.com/2012/02/22/poj-3764-the-xor-longest-path/","tags":[{"name":"ACM","slug":"ACM","permalink":"http://jinyouzhi.github.io/tags/ACM/"},{"name":"POJ","slug":"POJ","permalink":"http://jinyouzhi.github.io/tags/POJ/"},{"name":"Trie","slug":"Trie","permalink":"http://jinyouzhi.github.io/tags/Trie/"}]},{"title":"Hello World","date":"2017-03-26T15:59:04.231Z","path":"2017/03/26/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]